.. ##
.. ## Copyright (c) 2022, Lawrence Livermore National Security, LLC and
.. ## other RADIUSS Project Developers. See the top-level COPYRIGHT file for details.
.. ##
.. ## SPDX-License-Identifier: (MIT)
.. ##

.. _build_and_test-label:

*******************************************
Build and test without breaking your habits
*******************************************

The second Step in adopting RADIUSS CI infrastructure is to write a build
script that will take the Spack generated configuration file (host-config file)
and build and test your code using your usual development workflow.

Spack is not longer involved in at this point. But using the configuration file
will make sure the build uses the Spack installed dependencies and the options
specified by the Spack spec.

Using host-config files to build <Project>
------------------------------------------

When a host-config file exists for the desired machine and toolchain, it can
easily be used in the CMake build process:

.. code-block:: bash

  $ mkdir build && cd build
  $ cmake -C  <path_to>/<host-config>.cmake ..
  $ cmake --build -j .
  $ ctest --output-on-failure -T test

Debugging
=========

In the workflow described above, there are 4 levels of scripts to control the
build of a package. From the lower to the higher level:

* The *build system* is controlled by the host-config file (generated by Spack
  or not).
* The *Spack package* is controlled by the spec provided and the configuration.
* *Uberenv* takes a spec and a json configuration file.
* A *build_and_test script* also sometimes called test driver. The one in Umpire
  and RAJA requires a spec and some other control variables.

Now, when it comes to debugging, each level has some requirements to reproduce
a failing build:

* The *build_and_test script* typically runs in CI context. This means that it
  may not be designed to run outside CI. It is better if it does, and we try to
  do that in RADIUSS, but it is not guaranteed.
* *Uberenv* is meant to provide a turnkey way to install the project and its
  dependencies. It is usually a good way to reproduce a build on the same
  machine. The CI creates working directories in which the uberenv install
  directory _may_ persist, but it is better to reproduce in a local clone.
* Reproducing a build with *Spack* requires a deep knowledge of it. But Uberenv
  helps a lot with that. We advice that you use Uberenv to generate the Spack
  instance. Then, loading the spack instance generated and working with it is
  safe.
* Going down to the *build system* is also doable, especially when using
  host-config files. Once spack has installed the dependencies and generated
  the host-config files, it can be used to control the build of the code and
  this should not require using Spack.


